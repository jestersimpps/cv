---
title: "Getting Started with Ralph Wiggum Part 2: The Three-Phase Methodology"
description: "The professional workflow for multi-day autonomous coding projects. Separate planning from building, and wake up to production-ready features."
publishedAt: "2026-01-18"
author: "Jo Vinkenroye"
category: "Tutorials"
tags: ["Claude Code", "AI", "Automation", "Developer Tools", "Productivity", "Ralph Wiggum"]
coverImage: "/assets/blog/ralph-wiggum-coding.webp"
featured: true
series:
  id: "getting-started-ralph-wiggum"
  title: "Getting Started with Ralph Wiggum"
  part: 2
  total: 4
---

You installed Ralph, ran a loop, and... it kind of worked? Maybe it got stuck. Maybe it went in circles. Maybe it built something, but not quite what you needed.

That's normal. Ralph without structure is like any autonomous agent—capable but directionless.

This part covers the Three-Phase Methodology: a practical workflow for turning vague project ideas into working code while you sleep.

## The Core Insight: Separate Planning from Building

[Geoffrey Huntley](https://github.com/ghuntley/how-to-ralph-wiggum) describes it as **"A funnel with 3 Phases, 2 Prompts, and 1 Loop."** Here's the breakdown:

- **Phase 1: Requirements** — You + Claude in conversation, defining specs and acceptance criteria
- **Phase 2: Planning** — Claude analyzes specs (read-only loop), outputs prioritized TODO list
- **Phase 3: Building** — Claude implements tasks one by one, commits, loops until done

The separation is crucial. As [The Ralph Playbook](https://claytonfarr.github.io/ralph-playbook/) puts it: *"PLANNING prompt does gap analysis and outputs a prioritized TODO list—no implementation, no commits. BUILDING prompt picks tasks, implements, runs tests, commits."*

> **Why this works:** Planning mode prevents Claude from jumping into code before understanding the full picture. Building mode stays focused on one task at a time instead of scope-creeping into chaos.

## Phase 1: Requirements (The Human Part)

This is the only phase that requires your active involvement. And it's where most people cut corners—which is exactly why their Ralph sessions produce garbage.

**Spend at least 30 minutes** talking through requirements with Claude before writing any code. Seriously. This conversation is where you catch the "oh wait, what about..." moments that would otherwise derail your autonomous build.

![Roll Safe meme: Spend 30 min on requirements, get 8 hours of autonomous coding](/assets/blog/ralph-rollsafe.png)

### What Goes in Specs Files

Create `specs/*.md` files that become the source of truth. Don't overthink the format—focus on clarity:

> **Tip:** If you want a structured approach to requirements gathering, check out [JeredBlu's PRD Creator](https://github.com/JeredBlu/custom-instructions/blob/main/prd-creator-3-25.md)—a conversational prompt system that guides you through creating comprehensive specs.

```
specs/
├── authentication.md    # Login, JWT, sessions
├── api-design.md        # Endpoints, request/response formats
├── database.md          # Schema, relationships
└── testing.md           # Coverage requirements, test strategy
```

### The Conversation That Matters

Here's how a good requirements conversation flows:

```
You: "I want to build a REST API for managing todos"

Claude: "Let's break this down. What operations do you need?"

You: "CRUD operations - create, read, update, delete todos"

Claude: "Got it. What about authentication? User accounts?"

You: "Yes, users should only see their own todos"

Claude: "Makes sense. How should we handle..."
```

This back-and-forth surfaces edge cases you wouldn't think of alone. After the conversation, Claude generates structured specs documenting everything discussed.

> **The investment pays off:** 30 minutes of requirements conversation prevents hours of Ralph spinning on ambiguous goals.

## Phase 2: Planning

**This is a separate mode** using `PROMPT_plan.md`. You run planning mode explicitly when you need to generate or regenerate your implementation plan.

Planning mode does gap analysis between specs and code, creating a prioritized TODO list **without any implementation or commits**.

### Two Ways to Run Ralph

There are two methods for running Ralph loops, and understanding when to use each is critical:

**Plugin Method (`/ralph-loop`)** — Runs iterations within a single context window. Easier to set up, good for shorter tasks (under 20-30 iterations).

**Bash Loop Method (`loop.sh`)** — Launches a fresh Claude instance per iteration. As [Geoffrey Huntley's original guide](https://github.com/ghuntley/how-to-ralph-wiggum) explains, each iteration "deterministically loads the same files and reads the current state from disk." This prevents context bloat and hallucination that can occur when running many iterations in a single context. See community examples: [snarktank/ralph.sh](https://github.com/snarktank/ralph/blob/main/ralph.sh), [frankbria/ralph_loop.sh](https://github.com/frankbria/ralph-claude-code/blob/main/ralph_loop.sh), [peteristhegreat's gist](https://gist.github.com/peteristhegreat/31e7114805e24b9e38084772e2e7cf46).

> **Why fresh context matters:** The plugin runs everything in one context window, which fills up over time. After 30-40 iterations, Claude may start ignoring parts of your prompt or making inconsistent decisions. The bash loop method avoids this by starting fresh each time—the only shared state is what's written to disk (your code, `IMPLEMENTATION_PLAN.md`, and `progress.txt`). For advanced techniques, see [Advanced Context Engineering for Coding Agents](https://github.com/humanlayer/advanced-context-engineering-for-coding-agents).

We'll show you how to create `loop.sh` in [The Bash Loop Script](#the-bash-loop-script) section below.

### How to Run Planning Mode

For planning, the plugin method works well since you only need ~5 iterations (context bloat isn't a concern):

```bash
/ralph-loop "$(cat PROMPT_plan.md)" --max-iterations 5 --completion-promise "PLAN COMPLETE"
```

Or using the bash loop (see [The Bash Loop Script](#the-bash-loop-script) below):
```bash
./loop.sh plan
```

### PROMPT_plan.md Template

Here's the complete template for planning mode. For real-world examples, see [ClaytonFarr's PROMPT_plan.md](https://github.com/ClaytonFarr/ralph-playbook/blob/main/files/PROMPT_plan.md) or [snarktank's prompt.md](https://github.com/snarktank/ralph/blob/main/prompt.md).

```markdown
# PLANNING MODE

You are in PLANNING mode. Your job is analysis, not implementation.

## Your Task
1. Read all files in specs/
2. Review the existing codebase in src/
3. Perform gap analysis between requirements and current implementation
4. Create/update IMPLEMENTATION_PLAN.md with prioritized tasks

## Task Structure
Each task in the plan should include:
- Unique ID (e.g., TASK-001, TASK-002)
- Priority level (high/medium/low)
- Clear description (what needs to be built)
- Acceptance criteria (how you'll know it's done)
- Required tests (specific test files or patterns)
- Dependencies (tasks that must complete first)

## File Organization
Organize tasks by priority:
- High Priority: Critical path items
- Medium Priority: Important but not blocking
- Low Priority: Nice-to-haves

## Critical Rules
- DO NOT write any code
- DO NOT make any commits
- DO NOT implement features
- DO NOT run tests or builds
- ONLY analyze and plan

When complete, output "PLAN COMPLETE"
```

> **See real examples:** Browse actual prompt files from the community:
> - [snarktank/ralph](https://github.com/snarktank/ralph/blob/main/prompt.md) — Complete prompt.md with AGENTS.md
> - [ClaytonFarr/ralph-playbook](https://github.com/ClaytonFarr/ralph-playbook/blob/main/files/PROMPT_plan.md) — PROMPT_plan.md template
> - [frankbria/ralph-claude-code](https://github.com/frankbria/ralph-claude-code) — Implementation with exit detection

### What Planning Produces

Planning mode generates:

**`IMPLEMENTATION_PLAN.md`** - Your living TODO list

Example structure:
```markdown
# Implementation Plan

## High Priority

### TASK-001: User Authentication
- **Status**: pending
- **Description**: Implement JWT-based auth with login/logout
- **Acceptance Criteria**:
  - User can register with email/password
  - User can login and receive JWT token
  - Protected routes require valid JWT
- **Tests**: `auth.test.ts`
- **Dependencies**: none

### TASK-002: Todo CRUD Endpoints
- **Status**: pending
- **Description**: Create POST, GET, PUT, DELETE endpoints for todos
- **Acceptance Criteria**:
  - POST /api/todos creates a todo
  - GET /api/todos returns user's todos
  - PUT /api/todos/:id updates a todo
  - DELETE /api/todos/:id deletes a todo
- **Tests**: `todos.test.ts`
- **Dependencies**: TASK-001

## Medium Priority

### TASK-003: Input Validation
- **Status**: pending
- **Description**: Add Zod validation for all endpoints
...
```

**Important:** As [The Ralph Playbook](https://claytonfarr.github.io/ralph-playbook/) notes, the plan is disposable. If it becomes stale or inaccurate, delete it and regenerate by running planning mode again.

## Phase 3: Building

**This is the continuous loop mode** using `PROMPT_build.md`. This is where Ralph shines—autonomously implementing tasks while you sleep.

> **What is backpressure?** In the Ralph methodology, backpressure refers to automated validation mechanisms—tests, type checks, linters, builds—that reject unacceptable work. Instead of prescribing exactly *how* Claude should implement something, you create "gates" that reject bad output. Failing tests force Claude to iterate until the code is correct. This is the core insight behind autonomous coding loops.

Building mode assumes the plan exists, picks one task at a time, implements it with tests, commits, then loops with fresh context.

### How to Run Building Mode

**Quick start with the plugin:**
```bash
/ralph-loop "$(cat PROMPT_build.md)" --max-iterations 50 --completion-promise "ALL TASKS COMPLETE"
```

**For long-running builds (recommended):** Use the bash loop method for fresh context per iteration. After setting up `loop.sh` ([shown below](#the-bash-loop-script)):
```bash
./loop.sh              # Default mode is building
./loop.sh build 100    # With custom iteration limit
```

### PROMPT_build.md Template

Here's the complete template for building mode. For real-world examples, see [ClaytonFarr's PROMPT_build.md](https://github.com/ClaytonFarr/ralph-playbook/blob/main/files/PROMPT_build.md) or [frankbria's PROMPT.md](https://github.com/frankbria/ralph-claude-code/blob/main/templates/PROMPT.md).

````markdown
# BUILDING MODE

You are in BUILDING mode. Your job is implementation with quality gates.

## Your Task Loop
For each iteration:
1. Read IMPLEMENTATION_PLAN.md and progress.txt
2. Pick the SINGLE highest priority task with status: pending
3. Study existing code before implementing
4. Implement the feature completely
5. Write comprehensive tests
6. Run all tests and type checks: npm test && npm run type-check
7. If tests fail, fix them immediately—DO NOT proceed
8. When all tests pass:
   - Commit with descriptive message format: "feat(area): description"
   - Update task status to completed in IMPLEMENTATION_PLAN.md
   - Append learnings to progress.txt with timestamp

## Critical Rules
- Work on ONE task at a time—no exceptions
- NEVER commit failing tests
- NEVER skip test execution
- Tests are your backpressure—respect them
- Each commit must be atomic and working
- Don't add features not in the plan
- Don't refactor unrelated code

## Backpressure Enforcement
Tests MUST pass before committing:
```bash
npm test && npm run type-check && npm run lint
```

If any check fails, fix it in the same iteration.

## Progress Tracking
After completing each task, append to progress.txt:
```
[YYYY-MM-DD HH:MM] Completed TASK-XXX: Task Title
- What was implemented
- Key decisions made
- Challenges encountered
- Learnings for next tasks
```

When all tasks show status: completed, output "ALL TASKS COMPLETE"
````

> **See real examples:** Browse actual PROMPT_build.md implementations:
> - [ClaytonFarr/ralph-playbook](https://github.com/ClaytonFarr/ralph-playbook/blob/main/files/PROMPT_build.md) — PROMPT_build.md template
> - [frankbria/ralph-claude-code](https://github.com/frankbria/ralph-claude-code/blob/main/templates/PROMPT.md) — Implementation with intelligent exit detection
> - [mikeyobrien/ralph-orchestrator](https://github.com/mikeyobrien/ralph-orchestrator) — Enhanced orchestration implementation

> **Deep dive:** Geoffrey Huntley's [Don't Waste Your Back Pressure](https://ghuntley.com/pressure/) explains why validation and rejection mechanisms are critical for autonomous loops.

### The Bash Loop Script

Here's a `loop.sh` script that supports both planning and building modes. This pattern comes from [JeredBlu's guide](https://github.com/JeredBlu/guides/blob/main/Ralph_Wiggum_Guide.md) and [Geoffrey Huntley's original approach](https://github.com/ghuntley/how-to-ralph-wiggum):

```bash
#!/bin/bash
# loop.sh - Fresh context per iteration

MODE=${1:-build}  # Default to build mode
MAX_ITERATIONS=${2:-50}

if [[ "$MODE" == "plan" ]]; then
  PROMPT_FILE="PROMPT_plan.md"
  COMPLETION="PLAN COMPLETE"
  MAX_ITERATIONS=${2:-5}  # Planning needs fewer iterations
else
  PROMPT_FILE="PROMPT_build.md"
  COMPLETION="ALL TASKS COMPLETE"
fi

echo "Running in $MODE mode with max $MAX_ITERATIONS iterations"
echo "Using prompt: $PROMPT_FILE"
echo "Completion signal: $COMPLETION"
echo "=========================================="

for ((i=1; i<=$MAX_ITERATIONS; i++)); do
  echo "Iteration $i / $MAX_ITERATIONS"
  echo "--------------------------------"

  # The -p flag runs Claude in one-shot mode (see Mastery Part 1: https://jocv.dev/blog/claude-code-mastery-01-getting-started#one-shot-mode-quick-questions)
  result=$(claude -p "$(cat $PROMPT_FILE)" --output-format text 2>&1) || true
  echo "$result"

  if [[ "$result" == *"$COMPLETION"* ]]; then
    echo "=========================================="
    echo "$MODE complete after $i iterations."
    exit 0
  fi

  echo "--- End of iteration $i ---"
done

echo "Reached max iterations ($MAX_ITERATIONS)"
exit 1
```

Make it executable:

```bash
chmod +x loop.sh
```

**Usage:**
```bash
./loop.sh plan      # Run planning mode (default 5 iterations)
./loop.sh build     # Run building mode (default 50 iterations)
./loop.sh           # Same as ./loop.sh build
./loop.sh build 30  # Building mode with 30 iterations max
```

This gives you fresh context per iteration, preventing the context bloat that can occur with the plugin method on long runs.

For more sophisticated implementations with error handling, logging, and parallel execution, see [snarktank/ralph](https://github.com/snarktank/ralph/blob/main/ralph.sh) and [mikeyobrien/ralph-orchestrator](https://github.com/mikeyobrien/ralph-orchestrator).

### The Building Loop Flow

As [11 Tips for AI Coding with Ralph Wiggum](https://www.aihero.dev/tips-for-ai-coding-with-ralph-wiggum) documents:

1. Pick highest priority task from `IMPLEMENTATION_PLAN.md`
2. Implement the feature
3. Run all tests and type checks (**backpressure!**)
4. Commit only if everything passes
5. Update `progress.txt` with learnings
6. **Loop with fresh context** → repeat

**Key insight:** Each iteration runs in a fresh context window (with the bash loop method). This prevents context degradation and keeps Claude focused.

## Complete Three-Phase Workflow

Here's how it all flows together (using the `loop.sh` script from the [previous section](#the-bash-loop-script)):

```bash
# Phase 1: Define Requirements (conversational, not looped)
# Talk with Claude to create specs/*.md files
# Example: specs/authentication.md, specs/api-design.md, specs/database.md

# Phase 2: Generate Plan (run once, or when plan needs refresh)
./loop.sh plan
# Or with the plugin: /ralph-loop "$(cat PROMPT_plan.md)" --max-iterations 5 --completion-promise "PLAN COMPLETE"
# Creates IMPLEMENTATION_PLAN.md with prioritized tasks

# Phase 3: Build Autonomously (continuous loop)
./loop.sh
# Or with the plugin: /ralph-loop "$(cat PROMPT_build.md)" --max-iterations 50 --completion-promise "ALL TASKS COMPLETE"
# Implements tasks one by one, commits, loops

# When plan becomes stale (features changed, new requirements):
rm IMPLEMENTATION_PLAN.md
./loop.sh plan          # Regenerate plan
./loop.sh               # Resume building
```

### File Structure

Your project should have this structure:

```
your-project/
├── specs/
│   ├── authentication.md
│   ├── api-design.md
│   ├── database.md
│   └── testing.md
├── PROMPT_plan.md          # Planning mode prompt
├── PROMPT_build.md         # Building mode prompt
├── IMPLEMENTATION_PLAN.md  # Generated by planning, updated by building
├── progress.txt            # Append-only log of learnings
├── loop.sh                 # Bash orchestrator script
└── src/                    # Your actual code
    ├── api/
    ├── auth/
    └── tests/
```

### Key Differences Between Modes

**Planning Mode:**
- Prompt file: `PROMPT_plan.md`
- Goal: Analyze & plan
- Makes commits? No
- Writes code? No
- Runs tests? No
- Updates plan? Yes (creates/overwrites)
- Typical iterations: 1-5
- Run when? Once, or when refreshing plan

**Building Mode:**
- Prompt file: `PROMPT_build.md`
- Goal: Implement & test
- Makes commits? Yes
- Writes code? Yes
- Runs tests? Yes
- Updates plan? Yes (marks tasks complete)
- Typical iterations: 20-100+
- Run when? Continuously until done

## Essential Files for Long-Running Ralph Loops

### progress.txt

Track what's been accomplished across iterations. As [The Ralph Playbook](https://claytonfarr.github.io/ralph-playbook/) explains: *"The progress.txt is a standard long-running agent practice. Feed it to the agent via the prompt, and use the verb 'append' to make sure it doesn't update previous entries."*

Ralph reads this to understand context without re-exploring the codebase.

**How to use it:**
```
In your prompt, instruct the agent to:
"After each task, APPEND (don't overwrite) your learnings to progress.txt"
```

**Example progress.txt entry:**
```
[2026-01-16 14:30] Completed TASK-001: User Authentication
- Implemented JWT signing/verification using jsonwebtoken
- Added httpOnly cookie storage for tokens
- All auth tests passing (12/12)
- Learning: Cookie sameSite setting needed for cross-origin requests
- Challenge: Had to debug token expiry edge case
- Next: Tackle TASK-002 (Todo CRUD endpoints)
```

### IMPLEMENTATION_PLAN.md

Your living TODO list that Ralph updates as it completes tasks. This file bridges Planning and Building modes.

**Structure:**
```markdown
# Implementation Plan

## High Priority

- [ ] TASK-001: User Authentication (status: pending)
  - Tests: auth.test.ts
  - Dependencies: none

## Medium Priority

- [ ] TASK-002: Todo CRUD (status: pending)
  - Tests: todos.test.ts
  - Dependencies: TASK-001

## Completed

- [x] TASK-000: Project Setup (status: completed)
  - Completed: 2026-01-15 22:00
```

## Writing Effective Ralph Prompts

### Critical Prompt Elements

As documented in [11 Tips for AI Coding with Ralph Wiggum](https://www.aihero.dev/tips-for-ai-coding-with-ralph-wiggum), every Ralph prompt should include these elements:

**Progress Tracking:**
```
Read progress.txt to see what's been accomplished.
After completing each task, APPEND (never overwrite) your progress.
```

**Backpressure Through Testing:**
```
Each commit MUST pass all tests and type checks.
Run: npm test && npm run type-check && npm run lint
If anything fails, fix it before moving on.
NEVER commit broken code.
```

**Scope Control:**
```
Pick the SINGLE highest priority task from IMPLEMENTATION_PLAN.md.
Work ONLY on that task—don't add features or refactor unrelated code.
```

**Exploration First:**
```
Study the codebase first.
Don't assume something isn't implemented—verify by reading files.
Use ultrathink before making changes.
```

### Language Patterns That Work

Based on community learnings from [The Ralph Wiggum Playbook](https://claytonfarr.github.io/ralph-playbook/) and [11 Tips](https://www.aihero.dev/tips-for-ai-coding-with-ralph-wiggum), these phrases improve Claude's behavior:

- **"Study the codebase first"** → Reduces assumptions about what exists
- **"Don't assume not implemented"** → Encourages verification before writing
- **"Ultrathink before acting"** → Promotes careful planning before changes (`ultrathink` allocates maximum thinking budget for complex reasoning—see [Mastery Part 9](/blog/claude-code-mastery-09-power-user-secrets#extended-thinking-the-real-story))
- **"Capture the why in commits"** → Improves git history quality
- **"MUST pass all tests"** → Enforces quality gates strictly

## What's Next

You now have the professional methodology: specs for requirements, planning mode for gap analysis, building mode for autonomous execution. The file structure. The prompt templates.

In [Part 3: Ralph TUI Monitoring](/blog/ralph-wiggum-part-3-ralph-tui-monitoring), we'll cover real-time visibility for long-running loops—dashboards, keyboard controls, and session management.

Then in [Part 4: Advanced Patterns & Troubleshooting](/blog/ralph-wiggum-part-4-advanced-troubleshooting), we dive into advanced prompt engineering, common pitfalls, comprehensive troubleshooting, and enterprise-grade patterns.

<QuickReference>

**Phase 1: Requirements** — Talk with Claude, create `specs/*.md` files

**Phase 2: Planning** — Read-only loop: `/ralph-loop "$(cat PROMPT_plan.md)" --max-iterations 5 --completion-promise "PLAN COMPLETE"`

**Phase 3: Building** — Autonomous loop: `/ralph-loop "$(cat PROMPT_build.md)" --max-iterations 50 --completion-promise "ALL TASKS COMPLETE"`

**When plan becomes stale**

`rm IMPLEMENTATION_PLAN.md` then re-run planning mode

**Key takeaways**

Three phases with separate prompts: specs, planning, building

Planning mode generates the roadmap—no code, no commits

Building mode implements one task at a time

Tests are your backpressure—Ralph can't commit broken code

`progress.txt` preserves learnings across iterations

Plans are disposable—regenerate when stale

Atomic tasks work best—self-contained tasks that can complete in 2-3 iterations with clear pass/fail verification

</QuickReference>
