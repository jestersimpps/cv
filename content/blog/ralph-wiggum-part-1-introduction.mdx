---
title: "Getting Started with Ralph Wiggum Part 1: Introduction and Fundamentals"
description: "Install Ralph Wiggum and run your first autonomous coding loop in 15 minutes. Learn the core concepts, safety settings, and when to use it."
publishedAt: "2026-01-18"
author: "Jo Vinkenroye"
category: "Tutorials"
tags: ["Claude Code", "AI", "Automation", "Developer Tools", "Productivity", "Ralph Wiggum"]
coverImage: "/assets/blog/ralph-wiggum-coding.webp"
featured: true
series:
  id: "getting-started-ralph-wiggum"
  title: "Getting Started with Ralph Wiggum"
  part: 1
  total: 5
---

You're staring at a tedious migration task—200 test files that need converting from Jest to Vitest. The patterns are clear. The work is mechanical. But it's going to take you all day.

Or you could type one command, grab lunch, and come back to find it done.

That's Ralph Wiggum. And once you've used it, you'll wonder how you ever worked without it.

{/* IMAGE: Developer looking frustrated at screen vs developer relaxed with coffee while code commits - "Before Ralph vs After Ralph" */}

## What is Ralph Wiggum?

Ralph is a Claude Code plugin that turns your AI assistant into an autonomous coding agent. Instead of the usual back-and-forth—prompt, review, prompt, review—you give Ralph a task and walk away. It works until the job is actually done.

The philosophy is simple: **Iteration > Perfection**. Don't try to get it right on the first prompt. Let the loop handle it.

As [Geoffrey Huntley](https://github.com/ghuntley/how-to-ralph-wiggum), the technique's creator, puts it: "Ralph is a Bash loop." That's literally what it is—a `while true` that feeds Claude the same prompt until completion criteria are met.

Here's the mechanics:

1. You give Claude a task with clear completion criteria
2. Claude works on it and tries to exit when "done"
3. A Stop hook intercepts and checks: is it *actually* done?
4. If not, the same prompt gets fed back in
5. Claude sees its previous work in the files
6. The loop continues until genuine completion

**The key insight?** The prompt never changes—but the codebase does. Each iteration builds on the last. Claude reads its own previous work and improves on it.

{/* IMAGE: Simple flowchart showing the loop: Prompt → Work → Check → (if not done) → back to Work */}

## Why This Matters

This isn't theoretical. Developers are running 14-hour autonomous sessions that migrate entire codebases. Geoffrey Huntley ran a 3-month loop that built a programming language. [VentureBeat called Ralph](https://venturebeat.com/technology/how-ralph-wiggum-went-from-the-simpsons-to-the-biggest-name-in-ai-right-now) "the biggest name in AI right now."

The plugin was formalized by [Boris Cherny](https://github.com/anthropics/claude-code/tree/main/plugins/ralph-wiggum), Anthropic's Head of Claude Code. It's official. It's production-ready. And it's changing how serious developers work.

## Getting Started (5 Minutes)

### Step 1: Install the Dependency

Ralph needs `jq` for JSON processing. Install it first:

```bash
# macOS
brew install jq

# Ubuntu/Debian
sudo apt-get install jq

# Windows: Use WSL or grab it from https://stedolan.github.io/jq/
```

### Step 2: Install the Plugin

Inside Claude Code, run `/plugin` to open the plugin discovery interface. Search for "ralph" and select `ralph-loop` from the official plugins.

![Claude Code plugin discovery showing ralph-loop plugin](/assets/blog/wiggum-tutorial/plugin.png)

Or install directly with:

```bash
/plugin install ralph-loop@claude-plugins-official
```

### Step 3: Configure Permissions

Here's what trips up most people: Ralph runs autonomously, which means it can't stop and ask you "is this okay?" for every file edit. If you don't configure permissions, the loop breaks the moment Claude hits a permission prompt.

**Option A: Pre-approve in settings (recommended)**

Add the tools Ralph needs to your `.claude/settings.local.json`:

```json
{
  "permissions": {
    "allow": [
      "Edit",
      "Write",
      "Bash(npm test:*)",
      "Bash(npm run build:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)"
    ]
  }
}
```

**Option B: Use permission flags**

For long-running tasks in a sandboxed environment, you can bypass permission prompts entirely:

```bash
claude --dangerously-skip-permissions
# or
claude --permission-mode acceptEdits
```

> **Warning:** Only use `--dangerously-skip-permissions` in sandboxed environments (containers, VMs, disposable cloud instances). It gives Claude full access to your filesystem.

As [Boris Cherny notes](https://www.threads.com/@boris_cherny/post/DTBVuylEjqQ), for very long-running tasks you'll want either `--permission-mode=dontAsk` or `--dangerously-skip-permissions` in a sandbox so Claude isn't blocked waiting for you.

**Option C: Full Sandboxing (Recommended for Long-Running Tasks)**

For serious autonomous work, Claude Code's [built-in sandboxing](https://code.claude.com/docs/en/sandboxing) isolates Ralph while still allowing necessary operations. [JeredBlu's guide](https://github.com/JeredBlu/guides/blob/main/Ralph_Wiggum_Guide.md) provides a practical configuration—create `.claude/settings.json`:

```json
{
  "permissions": {
    "allow": [
      "WebFetch(domain:registry.npmjs.org)",
      "WebFetch(domain:github.com)"
    ],
    "deny": [
      "Bash(sudo *)",
      "Bash(docker *)",
      "Read(./.env)",
      "Read(~/.ssh/**)"
    ]
  },
  "sandbox": {
    "enabled": true,
    "autoAllowBashIfSandboxed": true,
    "allowUnsandboxedCommands": false
  }
}
```

Customize the allow/deny lists for your project's needs.

### Step 4: Run Your First Loop

Start small. Here's a safe first experiment:

```bash
/ralph-loop "Add JSDoc comments to all exported functions in src/utils.ts. Output <promise>DONE</promise> when complete." --completion-promise "DONE" --max-iterations 10
```

Watch it work. Review the commits. Get a feel for the rhythm.

{/* IMAGE: Terminal showing Ralph loop in action with iteration counter */}

## The Two Parameters That Matter

**`--max-iterations`** is your safety net. Always set it. The default is unlimited, which means Ralph will run forever if the completion promise never triggers.

> **Start small.** 10-20 iterations for your first few experiments. A 50-iteration loop on a large codebase can cost $50-100+ in API credits.

**`--completion-promise`** tells Ralph when to stop. It's exact string matching—Claude must output this precise text to signal completion.

```bash
/ralph-loop "<your task>" --max-iterations 30 --completion-promise "TASK COMPLETE"
```

## Plugin vs Bash Loop: Which to Use

There are two ways to run Ralph:

**Plugin Method (`/ralph-loop`)**
- Runs in a single context window
- Easier to set up
- Good for tasks under 20-30 iterations

**Bash Loop Method**
- Launches fresh context window per iteration
- Prevents context bloat and hallucination
- Better for long-running tasks

Here's a minimal bash loop example:

```bash
#!/bin/bash
# loop.sh - Run this instead of the plugin for long tasks
for ((i=1; i<=30; i++)); do
  echo "=== Iteration $i ==="
  result=$(claude -p "$(cat PROMPT.md)" --output-format text 2>&1) || true
  echo "$result"

  if [[ "$result" == *"ALL TASKS COMPLETE"* ]]; then
    echo "Done after $i iterations"
    exit 0
  fi
done
```

As [JeredBlu notes](https://github.com/JeredBlu/guides/blob/main/Ralph_Wiggum_Guide.md), the bash loop method is "fundamentally better for long-running tasks" because each iteration starts fresh. The plugin runs everything in a single context, which can lead to degraded performance after 30-40 iterations.

> **See real implementations:** Browse complete Ralph setups from the community:
> - [snarktank/ralph](https://github.com/snarktank/ralph) — Complete ralph.sh, prompt.md, and AGENTS.md
> - [ClaytonFarr/ralph-playbook](https://github.com/ClaytonFarr/ralph-playbook) — PROMPT_plan.md and PROMPT_build.md templates
> - [frankbria/ralph-claude-code](https://github.com/frankbria/ralph-claude-code) — Implementation with intelligent exit detection

**Recommendation:** Start with the plugin to learn. Graduate to bash loop for production long-running tasks.

## Writing Prompts That Work

Here's the difference between a prompt that spins forever and one that finishes cleanly:

**Bad prompt (vague completion):**
```
Make the code better.
```

**Good prompt (specific and testable):**
```
Add comprehensive error handling to src/api/users.ts.

Requirements:
- Wrap all async operations in try/catch
- Return proper HTTP status codes
- Log errors with context
- Add input validation for all endpoints

Run tests after each change. Fix any failures before moving on.

When ALL tests pass, output: <promise>COMPLETE</promise>
```

The good prompt has:
- **Clear scope** — specific file, specific changes
- **Testable criteria** — "tests pass" is binary, not subjective
- **Built-in quality gates** — "fix failures before moving on"
- **Explicit completion signal** — exact text to output when done

## When to Use Ralph (And When Not To)

**Ralph excels at:**

- **Mechanical refactoring** — Jest → Vitest, CommonJS → ESM
- **Adding tests** — "Get coverage to 80% on this module"
- **CRUD operations** — "Add user management endpoints with validation"
- **Documentation** — "Add JSDoc to all public functions"
- **Migrations** — "Update all imports to use path aliases"

**Don't use Ralph for:**

- **Aesthetic decisions** — "Make the UI prettier" isn't testable
- **One-shot edits** — If it takes 30 seconds manually, just do it
- **Production debugging** — You need context and judgment, not iteration
- **Unclear goals** — "Make it better" will spin forever

> **The rule of thumb:** If you can write an automated test for "done," Ralph can do it. If completion requires human judgment, do it yourself.

{/* IMAGE: Two columns comparison - "Ralph tasks" (mechanical, testable) vs "Human tasks" (creative, judgment-based) */}

## The Ralph Philosophy

[The Ralph Playbook](https://claytonfarr.github.io/ralph-playbook/) documents four core principles that make this work:

1. **Iteration > Perfection** — Don't try to nail it on the first prompt. Let the loop refine.
2. **Failures Are Data** — When Ralph fails, you learn how to write better prompts.
3. **Operator Skill Matters** — Your prompt quality determines Ralph's success rate.
4. **Persistence Wins** — The loop handles retries automatically. You just define "done."

The community mantra: *"Better to fail predictably than succeed unpredictably."*

## Monitoring Long-Running Loops

When Ralph runs for extended periods, you'll want visibility. **Ralph TUI** gives you a real-time dashboard: iteration count, current task, token usage, and keyboard controls to pause or stop.

We cover monitoring in detail in [Part 3: Ralph TUI Monitoring](/blog/ralph-wiggum-part-3-ralph-tui-monitoring).

## Choosing a Claude Plan for Ralph

Ralph works with Claude subscriptions or API access. Here's the quick guide:

- **Claude Pro ($20/mo)** — 10-30 iterations/session, good for learning and side projects
- **Claude Max 5x ($100/mo)** — 50-150 iterations/session, ideal for daily development
- **Claude Max 20x ($200/mo)** — 200-600+ iterations/session, professional long-running loops

**My recommendation:** Start with Pro to learn the workflow. Upgrade to Max 5x once you're running Ralph daily—it's 5x the capacity for 5x the price, which is fair. Go Max 20x if you're doing client work or need extended autonomous sessions.

> **The ROI math:** At $200/month for Max 20x, if Ralph saves you just 5 hours (at $40/hr billing), it's already paid for itself. Most serious users report 20-40+ hours saved monthly.

### Cost Management Tips

- **Always set `--max-iterations`** — Your real safety net
- **Start small** — 10-20 iterations until you understand the costs
- **Focused prompts = fewer iterations** — Vague prompts burn tokens
- **Track your usage** — Check at https://claude.ai/settings

## What's Next

You've got Ralph installed. You understand the loop. You know when to use it and when to do things manually.

But we've only scratched the surface.

In [Part 2: The Three-Phase Methodology](/blog/ralph-wiggum-part-2-methodology), we'll cover the professional workflow—separate prompts for planning and building, spec files that guide multi-day projects, and the techniques that make long-running autonomous builds actually work. This is where Ralph goes from "useful tool" to "force multiplier."

<QuickReference>

**Installation**

`brew install jq` — Install dependency (macOS)

`/plugin install ralph-loop@claude-plugins-official` — Install plugin

**Basic usage**

`/ralph-loop "<prompt>" --max-iterations 20 --completion-promise "DONE"`

**Safe first experiment**

`/ralph-loop "Add tests to src/utils.ts until coverage > 80%. Output <promise>DONE</promise> when complete." --completion-promise "DONE" --max-iterations 15`

**Key takeaways**

Ralph is an autonomous loop that iterates until tasks genuinely complete

Always set `--max-iterations` as your safety net

Start with 10-20 iterations to learn costs and behavior

Best for mechanical, testable tasks with clear completion criteria

Prompt quality determines success rate

</QuickReference>
