---
title: "Claude Code Mastery Part 9: Power User Secrets"
description: "The tips and tricks that separate casual users from Claude Code wizards. Learn ultrathink, git worktrees, keyboard shortcuts, and hidden features that boost productivity."
publishedAt: "2026-01-15"
author: "Jo Vinkenroye"
category: "Tutorials"
tags: ["Claude Code", "AI", "Power User", "Productivity", "Hidden Features"]
coverImage: "/assets/blog/claude-code-logo.webp"
series:
  id: "claude-code-mastery"
  title: "Claude Code Mastery"
  part: 9
  total: 10
---

The tips and tricks that separate casual users from Claude Code wizards. Some of these are documented, some discovered through experimentation, and some came from decompiling the Claude Code bundle.

## Extended Thinking: The Real Story

We first introduced extended thinking in [Part 2](/blog/claude-code-mastery-02-mental-model#extended-thinking-when-claude-needs-to-think-harder), but here's the complete story.

You've probably heard about "ultrathink" and "think harder." Here's what actually works according to [Anthropic's official documentation](https://www.anthropic.com/engineering/claude-code-best-practices).

### The Think Keyword Hierarchy

Claude Code maps specific phrases to thinking budgets. These are the **officially documented** trigger words:

**Think** (~4,000 tokens) — `think`

**Megathink** (~10,000 tokens) — `think hard`, `think deeply`, `think more`, `megathink`

**Ultrathink** (~32,000 tokens) — `think harder`, `think very hard`, `ultrathink`

```
Ultrathink about how to architect this authentication system
```

The higher the budget, the more "mental runway" Claude gets to consider multiple approaches, evaluate trade-offs, and catch edge cases.

![Claude Code ultrathink keyword with rainbow highlighting and max thinking indicator](/assets/blog/ultrathink-diagram.png)

### January 2026 Updates

A few things changed in Claude Code 2.1:

- **Thinking enabled by default for Opus 4.5** — No need to manually trigger it for complex tasks
- **Toggle changed from Tab to Alt+T** — Avoids accidental activation
- **Real-time thinking display** — Press `Ctrl+O` to see Claude's reasoning as it happens

### When to Use Each Level

**ultrathink** (~32K tokens) — Architecture decisions, security reviews, complex debugging, anything you'd schedule a meeting for

**think hard / megathink** (~10K tokens) — Multi-file refactoring, API design, debugging tricky issues

**think** (~4K tokens) — Quick analysis, code review, understanding unfamiliar code

**No keyword** — Simple fixes, typos, routine tasks where extended thinking just adds latency

**The rule:** Match thinking budget to problem complexity. Don't ultrathink a typo fix, don't skip thinking on architecture.

### Stay Current with Recent Information

Claude's training data has a cutoff date. For the latest library APIs, recent framework updates, or current best practices:

**Use Context7 MCP Server:** Fetches real-time, version-specific documentation. See [Part 7: MCP Servers](/blog/claude-code-mastery-07-mcp-servers#context7) for setup.

```
"use context7 to look up the current API for React Query v5"
```

**Ask Claude to search online:** Claude can perform web searches for recent information.

```
"search online for the latest Supabase auth patterns in 2026"
```

This ensures you're working with current APIs, not deprecated ones from Claude's training data.

## Multi-Window Power Moves

Don't wait for one task to finish. Run multiple Claude Code instances simultaneously—each in its own terminal, each with isolated context.

### Sound Notifications: Know When Claude's Done

When juggling multiple windows, you need to know when Claude finishes without constantly checking. Enable the terminal bell:

```bash
Claude config set --global preferredNotifChannel terminal_bell
```

You'll hear a beep when Claude completes a task or needs input. No more context-switching to check progress.

For richer notifications, use a hook in `~/.claude/settings.json`:

```json
{
  "hooks": {
    "Notification": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "afplay /System/Library/Sounds/Ping.aiff"
          }
        ]
      }
    ]
  }
}
```

This plays a sound on macOS whenever Claude needs attention. On Linux, use `paplay` or `aplay` instead. Windows users can use `powershell.exe -c "[System.Media.SystemSounds]::Beep.Play()"`.

### Cross-Repo Work: Reference Without Modifying

Working on a frontend that calls a backend API? Don't run Claude in both repos simultaneously. Instead, give Claude read-only access to the backend from your frontend project.

In your frontend's `.claude/settings.json`:

```json
{
  "permissions": {
    "additionalDirectories": ["../backend-repo/"],
    "allow": [
      "Read(../backend-repo/**)",
      "Grep(../backend-repo/**)"
    ],
    "deny": [
      "Edit(../backend-repo/**)",
      "Write(../backend-repo/**)"
    ]
  }
}
```

Now Claude can read the backend controllers and models to understand the API, but can't accidentally modify them. Ask things like:

```
"Check ../backend-repo/src/controllers/ for the user endpoints and wire up the frontend to match"
```

Claude reads the backend, understands the API shape, and writes only to your frontend.

### Same Project, Different Branches: Git Worktrees

When you need to work on multiple features in the *same* repo, git worktrees let you check out different branches in separate directories:

```bash
# Create worktrees for parallel features
Git worktree add ../myproject-dashboard feature/user-dashboard
Git worktree add ../myproject-notifications feature/email-notifications
```

Now you have:
```
Myproject/                    # main branch
Myproject-dashboard/          # feature/user-dashboard branch
Myproject-notifications/      # feature/email-notifs branch
```

Run Claude in each directory—completely isolated sessions, no branch switching conflicts.

### Why This Works

- Each Claude session has isolated context
- Read-only access prevents accidental cross-repo changes
- You can reference external code without risking modifications
- Context from one task doesn't pollute another

### Cleanup Worktrees

When done with a feature:
```bash
Cd myproject
Git merge feature/dashboard
Git worktree remove ../myproject-dashboard
```

## Screenshot and Image Input

Claude Code can see images. Drag and drop screenshots directly into your terminal.

### How It Works

1. Take a screenshot (Cmd+Shift+4 on Mac)
2. Drag the image file into your Claude Code terminal
3. Ask about it

### Use Cases

**UI Debugging:**
```
[drag screenshot of broken layout]
What's wrong with this layout? The button should be aligned right.
```

**Design Implementation:**
```
[drag mockup image]
Implement this design using Tailwind CSS
```

**Error Screenshots:**
```
[drag screenshot of error dialog]
What does this error mean and how do I fix it?
```

## Mermaid Diagram Generation

Have Claude create visual diagrams you can render anywhere.

### Architecture Diagrams

```
Generate a mermaid diagram showing the authentication flow in this app
```

Output:
```mermaid
SequenceDiagram
    participant U as User
    participant C as Client
    participant A as Auth Server
    participant D as Database

    U->>C: Enter credentials
    C->>A: POST /auth/login
    A->>D: Validate credentials
    D-->>A: User found
    A-->>C: JWT token
    C-->>U: Redirect to dashboard
```

### Where to Render

- **[mermaid.live](https://mermaid.live/)** - Online editor with live preview
- **GitHub** - Renders mermaid in markdown files and comments
- **VS Code** - With mermaid preview extension
- **Notion** - Supports mermaid code blocks

### Diagram Types

```
Create a mermaid flowchart showing the order processing states
```

```
Generate a mermaid class diagram for the data models
```

```
Make a mermaid ER diagram of the database schema
```

## Memory Bank Pattern

Persist context across sessions without bloating CLAUDE.md. This pairs well with the [Document + /clear Strategy](/blog/claude-code-mastery-02-mental-model#the-document--clear-strategy) from Part 2.

### Setup

Create a memory directory:

```bash
Mkdir -p .claude/memory
```

### Session Memory File

```markdown
# .claude/memory/current-session.md

## Active Focus
Implementing user dashboard feature

## Decisions Made
- Using React Query for data fetching (decided 2024-01-15)
- Chart library: Recharts (lighter than D3 for our needs)
- State: Zustand (team already familiar)

## Blocked On
- Waiting for design review on mobile layout
- Need API endpoint for activity feed

## Recent Changes
- Added DashboardLayout component
- Created useUserStats hook
- Set up Recharts for usage graphs

## Next Steps
1. Implement activity feed once API ready
2. Add export functionality
3. Mobile responsive tweaks
```

### Using Memory Files

Start sessions with:
```
Read .claude/memory/current-session.md and continue where we left off
```

Update at end of sessions:
```
Update .claude/memory/current-session.md with our progress today
```

## Token Optimization Tricks

Save money and improve response quality.

### Prefer /clear Over /compact

As we covered in [Part 2](/blog/claude-code-mastery-02-mental-model), `/compact` is tempting but risky. The summarization is opaque—you don't know what gets preserved or lost.

**Most of the time, `/clear` is better:**
- Starting something new
- Less than half your context is relevant
- You can easily re-establish what matters

**If you must use `/compact`, guide it:**
```
/compact Focus on preserving the authentication flow and database schema decisions
```

### Reference, Don't Paste

**Bad (wastes tokens):**
```
Here's the code:
[pastes 500 lines]

Fix the bug in this
```

**Good (efficient):**
```
Fix the bug in src/auth/login.ts around line 45
```

Claude will read the file itself, only loading what it needs.

**Pro tip: Copy Path in VS Code.** Right-click any file → **Copy Relative Path** (or `Cmd+Shift+Alt+C`). Paste the exact path instead of typing it. No typos, no ambiguity—especially useful for deep nested files or when multiple files have similar names. Combine with line numbers for surgical precision: `src/auth/login.ts:45-60`

### The Document & Clear Pattern

For complex multi-session work, don't trust compaction. Use explicit documentation:

```
"Save our progress and remaining TODOs to docs/feature-plan.md"
/clear
"Read docs/feature-plan.md and continue where we left off"
```

You control exactly what persists. No guessing what the summarizer kept.

## Model Switching Strategies

Different models for different tasks.

### When to Use Each Model

**Opus** ($$$) — Complex architecture, security reviews, novel problems that need maximum reasoning power.

**Sonnet** ($$) — General coding and everyday tasks. This is the default and handles most work well.

**Haiku** ($) — Quick questions, simple tasks, high-volume operations where speed matters more than depth.

### Strategic Model Usage

**Start complex features with opus:**
```
/model opus
Plan the architecture for user permissions system
```

**Switch to sonnet for implementation:**
```
/model sonnet
Implement the permission checking middleware we discussed
```

**Use haiku for quick checks:**
```
/model haiku
Does this regex pattern look correct? /^[\w-]+@[\w-]+\.[\w-]+$/
```

## Headless Mode Automation

Script Claude Code for CI/CD and automation using the `-p` (print) flag.

### Basic Usage

```bash
Claude -p "analyze this PR for security issues"
```

The `-p` flag runs Claude non-interactively and exits when complete. Perfect for scripts and pipelines.

### Output Formats

Control how responses are returned:

```bash
# Plain text (default)
Claude -p "summarize this project"

# JSON with metadata
Claude -p "list all TODO comments" --output-format json

# Stream JSON for real-time processing
Claude -p "analyze this code" --output-format stream-json
```

### Tool Auto-Approval

Pre-approve tools to avoid permission prompts in CI:

```bash
# Allow specific tools
Claude -p "run tests and fix failures" \
  --allowedTools "Bash,Read,Edit"

# Restrict to specific commands
Claude -p "create a commit" \
  --allowedTools "Bash(git diff:*),Bash(git log:*),Bash(git commit:*)"
```

### Pipeline Examples

```bash
# Automated PR review
Git diff HEAD~1 | claude -p "summarize these changes"

# Pre-commit hook
Claude -p "check staged files for secrets" || exit 1

# Security scan with JSON output
Claude -p "security review of this codebase" \
  --output-format json \
  --allowedTools "Read,Grep" | jq -r '.result'
```

### Session Continuation

Continue conversations programmatically:

```bash
# Get session ID from first call
Session_id=$(claude -p "start review" --output-format json | jq -r '.session_id')

# Continue that session
Claude -p "now check for performance issues" --resume "$session_id"
```

## Keyboard Shortcuts

Master these to navigate Claude Code faster.

### Essential Shortcuts

**Escape** — Interrupt Claude mid-response. Useful when you see it heading in the wrong direction.

**Escape, Escape** (double-tap) — Open command history. Scroll through previous prompts and re-run them.

**Ctrl+C** — Cancel current operation entirely.

**Ctrl+L** — Clear terminal display (not context, just visual clutter).

**Up Arrow** — Cycle through your recent prompts.

### In VS Code Extension

The Claude Code VS Code extension brings the same capabilities into your editor. It's not a separate product—it's Claude Code running natively in VS Code, sharing the same configuration, commands, and MCP servers.

**Cmd+L** — Open the Claude panel. This is where you'll spend most of your time—a persistent chat interface that understands your workspace.

**Cmd+Shift+L** — Send selected code to Claude. Highlight code, hit the shortcut, and Claude sees exactly what you're looking at.

**Cmd+I** — Inline editing mode. Claude edits code in place with a diff view—accept or reject changes without leaving your file.

**Cmd+Shift+P** → "Claude" — Access all Claude commands from the command palette.

The extension shares your `.claude/` configuration, so custom commands, MCP servers, and CLAUDE.md instructions work identically. The main advantage over terminal Claude Code: visual diffs, inline suggestions, and tighter editor integration.

### Voice Input: Talk to Claude

When I'm alone in the room, I often switch to voice. It's faster than typing for explaining complex problems, and sometimes talking through an issue helps clarify your thinking before Claude even responds.

On Mac, setup is simple: **System Settings → Keyboard → Dictation → Enable**. Then use the dictation shortcut (double-tap Fn by default) anywhere—including the Claude panel.

![Voice dictation settings on macOS](/assets/blog/voice.png)

Voice works especially well for:
- Explaining bugs you've been staring at for hours
- Describing UI changes while looking at a mockup
- Quick questions when your hands are on the trackpad
- Rubber-ducking problems out loud

The combination of voice input with Claude's understanding makes for surprisingly natural conversations about code.

## Hidden Productivity Hacks

### The "As If" Pattern

```
Implement this as if you were a senior engineer at Stripe
```

```
Review this code as if it's going to production tomorrow
```

Sets quality expectations without explicit requirements.

![Roll Safe meme - Can't write bad code if you pretend to be a senior Stripe engineer](/assets/blog/roll-safe-stripe-engineer.jpg)

### The Constraint Pattern

```
Implement this in under 50 lines
```

```
Solve this without adding new dependencies
```

Constraints often lead to better solutions.

### The Explain First Pattern

```
Before implementing, explain your approach in 2-3 sentences
```

Forces Claude to think before acting. Catch bad approaches early.

### The Rubber Duck Prompt

```
I'm stuck on [problem]. Ask me questions to help me figure it out.
```

Claude as debugging partner, not just code generator.

## Quick Reference

```bash
# Extended thinking keywords
"think about..."          # 4K tokens
"think hard about..."     # 10K tokens
"ultrathink about..."     # 32K tokens (max)

# Multi-window with git worktrees
Git worktree add ../feature-branch -b feature/name
Git worktree remove ../feature-branch

# Keyboard shortcuts
Escape          # Interrupt response
Escape Escape   # Command history
Ctrl+C          # Cancel operation
Up Arrow        # Previous prompts

# Token optimization (prefer /clear over /compact)
/clear                    # Reset context (preferred)
/compact Focus on X       # If you must, guide it
# Reference files by path instead of pasting

# Model switching
/model opus     # Complex tasks
/model sonnet   # General work (default)
/model haiku    # Quick questions

# Headless automation
Claude -p "task"                      # Basic
Claude -p "task" --output-format json # JSON output
Claude -p "task" --allowedTools "Read,Bash"  # Auto-approve tools
```

## What's Next

You've learned the power user secrets—ultrathink for deep reasoning, worktrees for parallel development, headless mode for automation, and the productivity patterns that make a difference.

In [Part 10: Vibe Coding](/blog/claude-code-mastery-10-vibe-coding), we'll wrap up with the philosophy of working with AI—when to let Claude drive, when to take the wheel, and how to develop your own intuition for AI-assisted development.

---

*Previous: [Part 8: Production Workflows](/blog/claude-code-mastery-08-production-workflows)*
